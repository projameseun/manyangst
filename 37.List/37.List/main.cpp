#include <iostream>
#include "FLinkedList.h"

int main()
{
	/*
		배열 과 링크드 리스트
		--배열--

		장점== 
		인덱스가 존재하여서 인덱스로 빠르게 접근이 가능하다
		배열은 연속된 메모리 블록에서 저장되므로 포인터를 위한추가 메모리(동적할당)가 필요하지 않는다.
		이는 오버헤드가 적다는 것을 말한다

		단점====
		삽입: 배열은 중간 만약에 어떤 데이터를 추가 하기 위해서는 해당 위치의 모든 요소를 한 칸씩 뒤로 밀어야 된다ㅣ.
		예를들어 1, 2, 4, 5 가 있는데 만약에 3을 추가하고싶다면 이를 위해서 4,5를 뒤로 밀어야 되고 그 안에 넣어 줘야되는 상황이 온다.

		삭제: 배열의 중간요소에 삭제를 하게 된다면 해당 위치의 모든 요소를 앞으로 한칸씩 당겨줘야된다.

		---링크드리스트---

		삽입:노드를 삽입하려는 위치를 찾은 후에 새로운 노드를 생성하고 포인터를 조정해 주면된다.
		예를들어 1,2,4,5가 있는데 2와 4 사이에 3을 삽입하려면 새로운 노드를 추가 해주면 된다.
		위치를 찾는데는 처음부터 가야되서 시간이 걸리기는 한다.

		삭제: 삭제할려는 노드의 이전 노드의 포인터를 삭제할 노드의 다음 노드로 변경하면된다.
		예를들어 1,2,3,4,5 에서 3을 삭제할려면 2의 다음 포인터 4를 설정하면 된다.

		오버헤드란?
		주어진 작업을 수행하기 위해 추가 필요한 메모리양을 말한다.
		예를들어서 10초 걸리는 기능이 간접적인 원인으로 20초 걸린다면 오버헤드는 10초가 되는것이다.

		메모리오버헤드--
		---배열----
		배열의 경우 메모리 오버헤드가 거의 없다. 이유는 연속된 메모리 블록을 사용하고 추가로 필요한 메모리가 거의없다.
		
		---링크드 리스트---
		각 노드는 데이터 뿐만아니라 다음 노드를 가리키는 포인터를 저장해줘야된다.
		예를들어 4바이트 정수 데이터를 저장하는 배열은 요소당 4바이트가 필요하지만 동일 한 데이터를 저장하는 
		링크드리스트는 데이터4+포인터4가 필요해서 8바이트가 필요하다.

		시간오버헤드---
		배열 
		접근은 매우빠르지만(인덱스 때문에)삽입과 삭제는 평균적으로 많이 소요 될수 있다.
		
		링크드리스트
		삽입 삭제는 노드의 포인터만 변경하면 되므로 빠르게 수행할수 있다.
		하지만 접근 할때는 처음부터 순차적으로 탐색해야 되므로 시간이 걸릴수 있다.

		링크드리스트는 힙영역에 메모리가 띄어져있다.
		그 다음 주소를 그래서 접근 못할거 같지만
		첫 위치를 head 마지막 위치를 tail로 만드는데
		예를들어 
		head에 데이터 100이 있다고 가정하자 근데 노드는 다음 주소를 가리키는 포인터도 가지고 있다
		그래서 띄어져있어도 다음주소를 알기 때문에 접근이 가능하다.
		

	*/

	_CrtSetDbgFlag(_CRTDBG_ALLOC_MEM_DF | _CRTDBG_LEAK_CHECK_DF);

	FLinkedList list = {};

	InitList(&list);

	PushBack(&list, 10);
	PushBack(&list, 20);
	PushBack(&list, 30);
	PushBack(&list, 40);
	PushBack(&list, 50);



	

	return 0;
}