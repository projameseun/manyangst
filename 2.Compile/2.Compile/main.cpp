#include <iostream>
#include "test.h"

#define MaxNumber 5000

/*
	c++코드로 작성한 프로그램이 실제 실행파일로 만들어 지는 과정
	                                   ==========컴파일 과정=======
	실행파일이 만들어지는 과정: 전처리 -> 컴파일 -> 빌드 -> 링킹연결 -> 실행파일 생성
										==========컴파일 과정=======

	컴파일(Compile):어떤 언어(c,c++,java등)의 코드 전체를 다른언어(기계어)로 바꿔주는 과정이다. 그리고 이것을 자동으로 수행해주는 프로그램을 컴파일러라고 부른다.
	따라서 소스코드를 실행 가능한 상태로 변환하기 위해 컴파일러 또는 인터프리터와 같은 프로그램을 사용한다.
	
	쉽게 설명을 다시해보면 c++같이 사람이 이해 할수있는 언어(고수준 언어)를 CPU가 이해 할수 있는 언어(저수준 언어:기계어,어샘블리어)로 번역하는 작업을 말한다.
	c++은 사용자가 알아들을수 잇는 언어이고 컴퓨터는 이해할수 없다.
	그래서 이거 컴퓨터가 이해 할수 있게 번역해주는일을 컴파일이라고 부른다.
	
	컴파일러:컴파일을 작업을 해주는 프로그램(컴퓨터가 이해 하도록 기계어로 번역해주는 프로그램)

	1.man(언어이름)을 c언어로 번역하든지, 아니면 기계어를 c언어로 번역하더라고도 컴파일이라고 우리는 칭할수 있다.
	대부분 근데 고수준언어를 기계어로 번역하는 프로그램을 일컫는다.

	디컴파일이란?
	컴파일러와 반대의 역할을 하는 컴퓨터 프로그램이다.
	기계어를 사용자가 사용하느 고급언어로 변환해주느 프로그램이다.
	
	컴퓨터 초기에는 프로그램을 작성하기 위해서 컴퓨터위에 바로 돌아가는 기계어를 통해 프로그래밍을 하였다.
	이런 과정은 생산성,호환성,디버깅등 모든면에서 효율적이지 않다...
	그래서 고수준언어를 작성하고 이를 번역기를 통해 기계어로 변역을 하게 되었다.
	
	컴파일러 와 비슷한 방식 프로그램이 인터프리터이다.
	컴파일러는 전체 소스코드를 읽고 분석하여 기계어로 번역하는 독립적인 프로그램을 말한다.
	반면, 인터프리터는 소스코드를 한 줄씩 읽고 번역하게 된다.
	
	==============컴파일러와 인터프리터의 차이점 ===========================
	1.작동방식
	컴파일러:전체 소스코드를 읽고 분석한 후에 기계어로 번역하여 실행 파일을 생성한다. 또 이렇게 생성된 파일은 독립적으로 실행 될수 있으며,
	실행 시에는 더 이상 소스코드가 필요하지 않다.
	인터프리터:소스코드를 한 줄씩 읽고 번역하여 즉시 실행한다. 즉 소스코드를 실행 하는동안 번역과 실행이 동시에 이루어 진다.
	
	2.실행속도
	컴파일러:소스 코드를 전체적으로 분석하고 번역하기 때문에 번역과정이 좀 더 오래 걸릴수 있지만, 실행 파일은 기계어로 되어 있어서 실행시에는 일반적으로 빠르다.
	인터프리터:코드를 한 줄씩 읽고 번역하고 즉시 실행하기 때문에 번역과정이 빠르지만, 실행 속도는 컴파일러에 비해서 상대적으로 느릴수 있다.
	
	3.오류발견
	컴파일러:전체를 번역하기 때문에 컴파일 과정에서 발생하는 오류를 미리 발견할수 있다.(애초에 오류가 나면 실행파일이 생성 되지 않는다).
	인터프리터:한 줄씩 실행하기 때문에 오류는 해당 줄이 실행 될때 발견된다.

	4.이식성(소프트웨어가 다른 환경 또는 플랫폼 에서 쉽게 이동하거나 실행될수 있는 능력)
	컴파일러:컴파일된 실행파일은 특정 플랫폼에서 종속적(소프트웨어나 시스템이 다른 요소나 구성요소에 의존하는 상태 모듈,라이브러리,프레임워크등을 말한다)일수 있으며,
	다른 플랫폼에서 실행하기 위해서는 다시 컴파일 해야될수 있다.
	인터프리터:일반적으로 플랫폼에 독립적이며, 소스코드를 실행하는 동안에 플랫폼에 맞게 번역되기때문에 이식성이 좋다.

	인터프리터를 사용하는 언어
	스크립트언어(인터프리터를 통해 실행되는 프로그래밍언어)
	대표적인게:python,javascript,php등이 있다.

	==============컴파일러와 인터프리터의 차이점 ===========================

	전처리(Preprocess):컴파일을 하기전에 하는 작업들을 말한다.
	프로그래머가 하나부터 열까지 모든 부분을 소스코드에 작성하지 않는다.
	외부에서 제공되거 또는 만들어진 라이브러리를 불러오거나, 컴파일러의 환경을 지정해주거나, 
	소스코드에 어떤 특장한 키워드를 만들어주거나 등 다양한 준비과정이 전처리때 하는일이다..
	
	//주석
	주석제거:소스코드에 주석을 전부 제거한다. 주석은 우리가 알아 볼수 있게 남긴 내용이기때문에 컴퓨터가 알 필요가 없다.

	#include 헤더파일 :컴파일러에 의해 다른 소스파일에 자동으로 포함된 소스코드파일이다.
	#include를 만나면 해당하는 헤더파일을 찾아 헤더파일에 모든 내용을 복사해서 소스코드에 삽입한다.
	일반적으로 선언을 많이한다.

	<>이 표시는 라이브러리 헤더파일로써 운영체제의 특별한 위치에 있다.
	""이 표시는 사용자가 직접만든 디렉터리에서 헤더파일을 include 하도록 전처리기에서 지시한다.

	매크로 치환 및 적용 :#define을 만나면 정의된 매크로를 지정하고 같은 문자열을 만나면 #define 된 내용을 치환한다.

	#pragma :프로그램의 이식성을 위해 특수한 상황을 컴파일러 에게 알려 줄때 사용한다.
	헤더파일이 중복될때 사용한다 그래서 일반적으로 클래스를 자동으로 만들게 되면 항상 #pragma가 생성된다.
	
	//조건부 컴파일...설명
	
	컴파일때 하는일 
	컴파일러가 컴파일 작업을 할때 기계어로 번역된 언어를 빌드해주면서 .obj(목적파일)라는 파일을 cpp마다 생성해준다.
	그런 후에 각 .obj파일들끼리 기능을 끌어다 사용하는게 있다면 링킹을 걸어서 사용할 수있게 해준후에
	최종적으로 기계어(0,1로 구성된언어)로 만들어서 실행파일을 만들어준다.

	빌드란?
	개발과정에서 소스코드를 컴퓨터가 실행파일 또는 배포가능한 형태로 변환하는 과정을 말한다.
	
	빌드하는 방법 
	Ctrl + b를 사용하여 컴파일을 하고 빌드를 해준다.
	Ctrl + f5를 이용해서 만들어진 실행파일을 실행시켜준다.

	목적파일이란?
	컴파일러가 소스 코드를 기계어로 번역하여 생성하는 중간 형태의 파일이다.
	목적파일에는 컴파일된 소스코드의 기계어 표현들이 들어있으며, 일반적으로 
	운영체제에 따라 조금 다르다 Window .obj 만들어지고 Unix,Linux는 .o으로 생성된다.

	목적파일에 용도..
	링킹,라이브러리,디버깅
	
	링킹(Linking):목적파일은 링킹에 의해 다른 목적파일과 함께 결합되어 실행 파일이나 라이브러리로 만드는 과정을 말한다.
	이 과정에서는 각 목적파일이 참조하는 외부변수나 함수,라이브러리등을 연결하여 실행 가능한 형태의 프로그램을 만든다.
	
	따라서 링킹은 여러개의 목적파일을 결합하여 실행파일을 만드는 과정을 의미하고, 이과정을 수행하는 프로그램이 링커다.

	디버깅:코드를 작성하다보면 어 떤값이 들어있는지? 또는 어디서 오류가 났을때
	중단점 걸어서 그 위치에서 발견하거나 버그의 원일을 찾아 수정하는 과정을 디버깅이라고 한다.
	F9을 통해서 디버깅을 할 수 있다.

	라이브러리:컴퓨터에서 즉시 개발자들이 사용할수 있도록 공통적으로 사용 될수 있는 특정한 기능을 모듈화 한것이다.
	
	===모듈과 모듈화의 차이===
    모듈(Module)이란?
	모듈은 프로그램을 구성하는 작은부분이며(함수,클래스) 일반적으로 특정기능이나 작업을 수행하는 독립적인 단위를 나타낸다.
	모듈은 관련된 기능을 묶어서 관리하기 쉽도록하고, 코드의 재사용과 유지보수를 높이기 위해서 사용된다.
	모듈은 보통 파일 단위로 구현되며,하나의 파일에는 하나 이상의 모듈이 포함될수 있다.
	
	모듈화(Modularization)이란?
	작은 모듈을 분해하고, 각 모듈간의 상호작용을 최소화 하는 설계및 방법론을 말한다.

	요약하면 
	모듈은 프로그램을 구성하는 작은부분이며, 모듈화는 작은 모듈을 분해하고, 각 모듈간의 상호작용을 최소화하여 설계한 것이다.
	예를들어 하나의 함수는 모듈이고 그 함수가 모여서 하나의 기능을 만들게 된다면 그것이 모듈화 라고 말 할수 있다
	
	
	===모듈과 모듈화의 차이===

*/


int main()
{
	int iNumber = 0;

	//한줄 주석
	/*
	여러개로
	주석이
	가능하다
	*/
	std::cout << "test" << std::endl;

	test m_test;

	m_test.MonsterSetting();

	m_test.MonsterCout();

	std::cout << MaxNumber << std::endl;
	

	return 0;
}