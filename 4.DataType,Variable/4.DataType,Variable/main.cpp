#include <iostream>
#include <bitset>

/*
	변수(Variable) :메모리(램)에 공간을 만들고 해당 공간에 값을 저장해서 사용해 줄수 있는기능

	자료형(Data Type)
	정수형:int(4), char(1) , short(2) ,long(4)...
	실수형:float(4) , double(8) ....

	int a = 0;
	int는 정수이다.
	int 4byte크기를 갖고 있다.
	0 ==> 값이라고 부른다.
	= 대입연산자라고 부른다
	int는 자료형이라 부른다
	a는 변수라고 부른다.

	컴퓨터의 기본크기 단위

	1bit 는 0,1 두가지를 표현할수 있다. 컴퓨터의 가장 작은 단위다.
	1byte = 8bit
	 1bit가 (0,1) 두가지를 표현할수 있기때문에 8bit는 2의8승이므로 256가지를 표현할수 있다. 

	 1Kbyte = 1024byte
	 1Mbyte = 1024kbyte
	 1MGByte = 1024Mbyte
	 1TBbyte = 1024GByte

	 int 4byte를 bit 표현하면 32bit이다.

*/


int main()
{
	int iNumber = 0;
	//iNumber의 변수는 컴파일 과정에서 컴퓨터가 보는 방식과 사용자가 보는방식이 다르게 표현이된다.
	//컴퓨터는 컴파일 과정에서 본인이 알아들을수 있게 변환한다. // 변환하는방식---> (변수 ====>메모리주소(fffbbbxxxx)) 


	iNumber = 100;

	//char 는 1byte이면서 8bit이다.
	//256가지를 표현할수 있다.
	char ch = 0; //음수 0 양수를 다취급
	unsigned char unch2 = 0; //0,양수를 취급

	ch = 48;  //아스키코드에 의해서 숫자 0 이 나온다
	ch = '8'; //' ' 는 단일 문자를 표현할수 있는데 두개의 문자가 들어가 있기때문에 컴파일 오류를 발생시킬수 있고, 4 또는 8이나온다. 정확히 할려면 따로 써야된다.

	std::cout << ch << std::endl;

	//아스키코드 --> 컴퓨터에서 문자를 표현하기위해 사용되는 표준코드

	ch = 256;
	std::cout << ch << std::endl;

	//오버플로우(Over Flow)
	//변수가 표현할수 있는 최대의 범위를 넘어가는 경우를 오버플로우라고 한다
	
	//언더플로우(Under Flow)
	//변수가 표현할수 있는 최소의 범위를 넘어가는 경우를 언더플로우라고 한다

	//unch2 = 255;
	unch2 = -1;
	ch = 255;
	int a = 0;

	//비트단위로보기
	std::cout << "ch : " << std::bitset<8>(ch) << std::endl;
	std::cout << "unch2 : " << std::bitset<8>(unch2) << std::endl;

	/*
		음수표현
		
		컴퓨터에서는 음수를 표현할때는 1byte의 기준으로 살펴보면 8개의 모든숫자를 저장하는게 아니라 
		7개만 저장되고 가장 왼쪽비1개는 음수 또는 양수 인지 구별하게 된다.
		여기서 양수와 음수를 구별 할수 있는 비트를 부호비트MSB(Most Sgnificant Bit) 또는 최상위비트라고 부른다

		컴퓨터에서 말하는 음수란
		수학에서는 빼기라는 개념이 존재하지만 컴퓨터는 빼기라는 기능이 존재 하지않는다
		오로지 더하기로 만 연산이 가능하다
		20 - 10 = 10 이라고 말할수 있지만 20 + (-10) =10 이라고도 말할수잇다 
		
		★★★★★★
		8비트기준에서
		1000 0001 -> 이건 -1이 절대아니라는걸 알아야된다.

		================
		0111 1111 --->127
		1000 0001 ---->-127 2의보수를 사용하면 이렇게 나온다.
		===================
		0

		1000 0001 signed에서는 -127이라는 거다 -1이 절대아니라 

		★★★★★★둘의 메모리 비트값은 똑같다 ★★★★★★
		255라는 숫자는 똑같이 1111 1111 으로 채워져있다
		근데 부호가 있는 마이너스를 채용하면 비트는 최상위트msb를 부호 용도로 사용하고 있다
		결국은 어떤 관점에서 보느냐에 따라 다른것이다.
		unsigned냐 signed냐에 따라...

		음수를 쉽게 찾는법
		보수 --> 보충해주는수...
		
		1 에대한 10의 보수는 9
		4 에대한 6의 보수는 2
		
		2의보수법
		대응 되는 양수의 숫자를 반전시킨다(1의보수), 1의 보수후에 +1을 더한다(2의보수)
		
		0 0 0 0 0 0 1 0 ====> 2
		1 1 1 1 1 1 0 1 ====> 반전시킨다
		1 1 1 1 1 1 1 0 ====>+1 을 해준다(2의보수)
	==========================================
	
	실수
	정수형 과 실수형은 처리하는 방식이 완전 다르다.
	정수랑 실수는 표현하는 메모리방식 자체가 다르다.
	컴퓨터에서는 실수는 부동소수점을 사용한다...



	*/
	float fNumber = 234.3f;
	
	std::cout << std::bitset<32>(fNumber) << std::endl;

	double dNumber = 33.3;

	 /*
		변수의타입
		타입				||		크기				||		표현종류			||		표현범위														||		unsigned							||
	 	char			||	1byte				||		문자				||		-128~127													||		0~255								||
	 	bool			||	1byte				||		참/거짓			||		false(0),true(1)											||											||
	 	short			||	2byte				||		정수				||		-32,768~32,767												||		0~65,535							||
	 	int				||	4byte				||		정수				||		-2,147,483,648 ~ 2,147,483,647								||		0~4,294,967,295						||
	 	__int64			||	8byte				||		정수				||		-9,223,372,036,854,775,808 ~ 9,223,372,036,854,775,807		||											||
	 	float			||	4byte				||		실수				||																	||											||
		double			||	8byte				||		실수				||																	||											||
	 
	 
		bool 0은  false
		0이아닌 모든수를 true
		

	 
	 
	 
	 */

	bool bTest = 10;
	bool bTest2 = 0;

	std::cout << bTest << std::endl;
	std::cout << bTest2 << std::endl;
	
	short sTest = 0;
	sTest = 32768;

	std::cout << sTest << std::endl;

	 iNumber = 0;
	iNumber = 252525;
	__int64 iBossHP = 41412445665;
	
	float fNumber2 = 3.5f;
	
	fNumber2 = 55.5;
	
	/*
		변수의 특징
		카멜 표기법 myName , fireMagic , boosRica, totalNumaber
		첫글자는 대문자로 적되,맨앞에 글자는 소문자로 표기하는방식
		낙타의 혹처럼 보인다고 카멜 표기법이라고 부른다.

		헝거라인 표기법 자료형을 확인하기 어려워서 변수 이름을 정할때 앞에 변수의 특성을 알수있께 접두어를 붙인다
		i_data, fNumber , sh_Number, strName 등
		변수를 만들때 변수이름만 보고 자료형을 알수 있게 만드는것이 특징
	
	*/

	int iTest = 0;

	
	

	return 0;
}