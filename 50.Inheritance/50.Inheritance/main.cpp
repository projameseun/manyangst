#include <iostream>

//#pragma pack(1) 패딩을 제거하는 법
class CTemp
{
	int a;
	int b;
	double e;
	char c;
	char d;
	short f;
};
//#pragma pack() 

class CParent
{
private:
	int m_i;	//멤버변수
	double m_d;
	//short m_c[8];
protected:
	int m_j;

public:
	 virtual void Func()	//멤버함수
	{
		std::cout << "부모 함수" << std::endl;
	}

	void Attack()
	{

	}
	
public:
	CParent() :
		m_i(0),m_d(0.f),m_j(0)
	{
		std::cout << "CParent Constructor" << std::endl;
	}
	~CParent()
	{
		std::cout << "CParent Destructor" << std::endl;
	}

	
};

class CChild : public CParent
{
public:
	int m_k;
	float m_f;

public:
	 void Func() override
	{
		std::cout << "자식 함수" << std::endl;
	}

	void Attack()
	{

	}
public:
	CChild() :
		//CParent(),
		m_k(0),m_f(0.f)
	{
		std::cout << "CChild Constructor" << std::endl;
		
	}
	~CChild()
	{
		std::cout << "CChild Destructor" << std::endl;
	}

};

class Test
{

};

int main()
{
	//상속 
	//클래스간에 부모와 자식의 관계를 형성 시켜줄수 있는 기능이다.
	//A클래스 B클래스가 있을때 B가 A를 상속받고 있다면
	//A를 부모클래스(기본클래스) B를 자식클래스(파생클래스)라고 부른다.
	//B는 상속받고 A의 멤버함수,멤버변수를 물려받아 사용할수 있다.
	//이때 A에 ,pirvate로 되어 있다면 지삭에서는 접근 불가능

	//클래스크기
	//제일 큰 변수의 메모리를 기준으로 잡아 나간다.
	//이유는 패딩바이트 때문에 그렇다.
	//패딩 바이트란? 
	//클래스,구조체에 패딩 바이트를 추가하여서 CPU접근을 더 용이하게 해 주는 것을 말한다.
	//공간 낭비될수 있는 패딩공간을 확보하면서 메모리의 크기를 맞추는데 이유는 CPU연산 횟수를 줄이기 위해서이다.
	//32비티는 CPU한번 에4Byte , 64비트는 한번에 8Byte 읽어들이는데
	//패딩 바이트를 사용하지 않게되면 byte가 남게되어 연산을 두번 하게 되는 상황이 온다.
	//컴퓨터는 4,8바이트식으로 정렬된 상태로 처리하는것을 선호하게 되고 비정렬 데이터는 성능 저하를 유발시킬수 있다.
	//핵심 CPU데이터를 읽고 쓸때 메모리정렬이 맞지않으면 성능 저하가 된다.
	



	//CParent parent;		//객체

	//parent.m_i = 10;

	CChild child;

	//자식을 호출했을때
	//초기화는 부모부터 일어나지만
	//호출순서는 자식부터 일어난다 헷갈리지않기
	//생성자 호출순서 자식 -> 부모 
	//생성자 실행순서 부모 -> 자식
	//소멸자 실행순서 자식 - > 부모 



	size_t size = sizeof(CTemp);

	//다형성 : 상속 관계에 있어서 클래스들은 서로 형변환이 가능하다.
	//자식 클래스를 부모클래스로 형변환이 가능하고, 부모 클래스를 자식클래스로 형변환이 가능하다.
	//자식 -> 부모 형변환 : 업캐스팅
	//부모 -> 자식 형변환 : 다운캐스팅 

	//업캐스팅은 안전한 형변환이다.
	//ex)CParent* pCp = &ch; 포인터는 주소를 가리키는데 이때 부모 pCp는 부모클래스 주소를 갖고 있다 ch변수는 부모 자식을 둘다 갖고 있기 때문에
	//그 주소로 접근이 가능하다 때문에 안전하다.

	//반대로 다운캐스팅은 안전을 보장할수 없다.
	//ex)Cchild* pCh = &p; 이런경우에는 pCh는 자식클래스를 갖고 이ㅏㅆ는데 이때 p변수는 부모크기만 갖고 있기때문에 자식에 접근이 불가능하다.


	CChild ch;
	CParent p;

	CParent* pCp = &ch; //업캐스팅

	//CChild* pCh = (CChild*)&p;	//다운캐스팅 

	//pCh->Func();

	//부모를 강제로 호출할때 
	

	//오버라이딩
	//상속에서만 사용이 가능하다.
	//상속받은것들중에 새로운 기능을 추가하거나 다른 기능을 하도록 변경하는것을 오버라이딩이라고한다.
	//또한 이미 부모클래스에 정의된 함수와 같은이름을 자식클래스에서 재정의할때 가능하다.

	//override는 부모가 갖고있는 함수를 자식이 똑같이 사용한다고 overide가 아니다
	//정확히는 부모가 가상함수를 갖고 있을때 자식이 똑같은 함수를 갖고 있을때 override가 된것이다.
	//이는 다형성이라고 부를수 있다.

	//오버라이딩을 하는이유
	//자식의 재정에 핵심이 있다.
	//게임으로 에를든다면
	//Skill이라는 부모클래스가 있고
	//자식쪽에 수많은 스킬을넣었을때
	//자식쪽 마다 모두 다른기능을 쓰고 싶을때가 있을것이다. SKILL이라는 본체는 같지만 기능은 다다르게 사용할려고 사용한다
	//결국 SKILL을 통하는건 같지만 결과값은 모두 종류마다 다를것이다.
	//어떤 한가지 클래스가 있지만 그 기본 기능을 가진 자식들은 모두 다양하게 결과 값을 다르게 하고싶기 때문에 이럴때 재정의함으로써 오버라이딩을 사용한다.
	//결론은 상속받은 클래스자식에에서 부모클래스의 함수를 재정의함으로써 동일한 인터페이스를 사용하면서도 자식클래스마다 다른 동작을 사용할수 있게 만들어주는게 핵심이다.
	//코드의 유연성:게임 개발은 변화가 매우빨라 부모클래스(기본틀)은 변경하지 않고 업데이트 될때마다 새로운 자식클래스에서 새로운 기능을 추가할수 있고 수정할수 있다.
	//상속 구조를 재사용 함으로써 각기 다른방식으로 행동 할수 있게 만들수 있다.

	//바인딩?
	//연결이라는 의미랑 비슷한대 함수호출과 함수의 실체 구현을 연결하는 과정을 바인딩이라고 부른다.

	//동적바인딩
	//컴파일이 아닌 런타임에서 결정되는 방식이다.
	//주로 가상함수에서 발생하며, 실행중에 어떤 함수가 호출될지 결정한다.

	//정적바인딩 
	//컴파일에서 결정이 난다 Undefine behavior이 일어날수있다.

	//static클래스 함수, 강제 부모,자식호출방법


	
	return 0;
}