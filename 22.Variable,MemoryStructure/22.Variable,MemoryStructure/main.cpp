#include <iostream>
#include "Calculate.h"

int data = 0;


void Func()
{
	int a = 0;

	++a;
	
	g_Num++;
	g_Num++;
	g_Num++;
	g_Num++;
	g_Num++;


	data++;

	std::cout << "a = " << a<< std::endl;

	std::cout << "data = " << data << std::endl;

	std::cout << "g_Num = " << g_Num << std::endl;

	
}


void StaticFunc()
{

	g_StaticNum++;
	g_StaticNum++;

	static int g_StaticNum2 = 0;		//초기화를 0으로 한번만 하고 2번째 들어올때는 건너간다. 실제 어샘블리어코드에서 해주고 있는게 있다.
										//g_StaticNum2 변수는 ++을 하게되고 계속 함수를 실행하면 값이 0으로 초기화 되는게 아니라 값이 계속 ++되고 있는 것이다.
	g_StaticNum2++;

	std::cout << "g_StaticNum2 : " << g_StaticNum2 << std::endl;
}


int main()
{
	/*
		변수의 종류 4가지 
		1.지역변수 
		(메모리)가 해당 코드블럭을 벗어났을때 해제가 된다.
		쓰임:해당 지역에서만 사용이 가능하다.

		2.전역변수
		프로그램을 실행할때 (메모리)가 생성 되고 종료 될 때 해제 된다.
		쓰임:모든 지역에서 사용이 가능하다.
		
		3.static변수(정적변수)
		(메모리)는 전역변수랑 같다 그러므로 프로그램을 실행할때 생성되고 종료 될때 해제된다.
		쓰임:지역변수랑 흡사하다. 같은 지역에서만 사용이 가능하다.

		외부파일에서 접근했을때 이름은 같지만 서로 다른 변수이다. 이 말은 주소가 다르다는 것이다.
		
		4.외부변수(extern)
		외부변수 라고 부르고 전역으로 쓰이면서 외부에파일에서도 똑같은 공용으로 쓰는 변수이다.
		이 말은 주소가 결국 같다는 말이다.

		메모리구조
		저장되는 순서: Code -> Data(GVAR,BSS), Heap , Stack

		ROM(Read Only Memory) = Read Only 

		RAM(Random Access Memory) = 저장된 데이터를 순차적인게 아닌 임의의 순서로 액세스 할수 있는 데이터 저장소이다 Read,Write 가능

		Random Aceess Memory는
		1.동일한 접근시간:메모리가 특정위치에 접근할때 걸리는 시간이 그 위치에 상관없이 일정하다는 것을 말한다.
		즉,메모리가 어느주소에 있는 데이터든지 동일 한 시간안에 접근할수 있다는 것이다.
		2.효율적 데이터 처리:RAM은 CPU가 데이터를 효율적으로 읽고 쓸수 있게 하여 프로그램 실행속도를 높인다. CPU랑 물리적으로 가까워서 빠르게 접근가능
		3.휘발성:RAM은 전원이 꺼지면 데이터가 사라지는 휘발성 메모리이다.

		비유을 통한 설명
		1.RandomAccess : 책장에서 아무 책이나 바로 꺼낼수 있는 상황 첫번재나 열벌째나 모두 어디에서든 꺼내도 걸리는 시간은 같다.
		2.Sequential Access :테이프,CD같은경우에는 순차적으로 읽어줘야된다. 이런경우 특정 데이터를 찾기위해서 처음부터 차례로 읽어나가야 하므로, 끝에있는 데이터를 읽위해서는 오랜시간이 걸릴수 있다.

		CPU가 RAM에 빠르게 접근할수 있는 이유
		1.물리적 접근성: RAM은 일반적으로 CPU와 가까운 위치에 있다. 반면 , HDD,SSD는 상대적으로 CPU와 멀리 떨어져있다 그래서 상대적으로 느리다.
		2.데이터 전송속도 : RAM은 전기 신호를 이용해 데이터에 저장하고 있다, 나노추(ns) 단위로 접근시간이 측정된다고 한다. 반면, 디스크는 기계적인 움직을 필요로 하며 데이터 접근시간이 밀리초(ms)단위로 측정된다.
		3.랜덤 액세스 :RAM은 걸리는 시간이 위치에 상관없이 일정하다 반면, 순차적 앤세스는 특정데이터를 찾기 위해서 처음부터 순서대로 읽어야된다.
		4.메모리 계층구조 : CPU내부안에 캐시 메모리(L1,L2,L3캐시)가 있는데 이 메모리는 용량이 매우작다. RAM은 이보다 큰용량제공하며, 매우빠른 접근속도를 제공한다.
		이러한 메모리 계층구조는 CPU가 필요한 데이터를 가장 빠른 메모리에서 찾도록 설계되어있다.

		컴퓨터의 메모리 계층구조 
		CPU 레지스터,L1,L2,L3캐쉬 // RAM , SSD/HDD


		=============메모리영역 =========================================

		=========RAM==================
		stack영역 - 지역변수,함수의 매개변수(컴파일 때 크기가 결정된다.) 해당 함수를 벗어날시 메모리가 사라진다.
		heap영역 - 사용자가 직접 할당하고 해제하는 공간 //malloc, new등을 사용해서 동적할당이 되는 변수들이 heap영역에 할당 된다.
				   만약에 메모를 사용자가 해제를 안하게 되면 메모리 릭이 생긴다(런타임때 크기가 결정된다)

				   스택영역과 힙영역은 사실상 같은 공간을 사용한다.
				   그래서 스택영역이 클수록 힙영역이 작아지고, 힙영역이 클수록 스택영역이 작아진다.

				   스택 영역은 높은주소 -> 낮은주소로 할당되고
				   힙 영역은 낮은주소 -> 높은주소로 할당된다.
				   이때 자신의 영역이 상대의 영역을 침범하는 사례가 발생할수 있는데, 이를 각각 스택 오버플로우, 힙 오버플로우 라고 부른다.

				   
				   
		data영역은 크게 (GVAR,BSS)영역을 합쳐 일컫는 말이다.
		BSS,GVAR영역을 나뉘는 이유..
		메모리의 효율 적인 사용과 프로그램의 초기화에 있다.

		BSS(Block Started by Sybmol)
		초기화 되지 않은 데이터 저장
		BSS는 초기화가 되지 않은 전역변수와 정적변수를 저장하는 영역이다.
		변수가 초기화가 되지 않은 경우 0,NULL로 들어가게 되있다.
		따라서 BSS에 할당된 변수들은 프로그램 실행 시 메모리의 초기화에 필요한 시간자원을 절약가능하다.

		GVAR(Global Variable)
		전역범위의 변수를 접근 가능하게 한다.(전역변수,static변수,배열,구조체등이 저장됨)
		전역변수들은 프로그램 전체에서 사용이 가능하다. 이러한 변수들은 어디에 저장 되어 있는지 명확한게 중요하다.
		GVAR를 사용하여 전역변수들이 BSS에 저장된것을 나타내면, 전역변수들을 쉽게 관리하고 추적 할수있다.

		=========RAM==================

		========ROM===================
		코드영역- 텍스트 영역이라고 부른다 사용자가 작성한 코드가 저장되는 영역이다.
		명령문들이 저장되는곳,제어문,함수,상수들이 해당된다.
		프로그램이 실행중에 수정되지 않고 오직 읽기만 가능하다.
		코등영역에 데이터는(명령어,상수등값) 프로그램이 실행 되기 전에 이미 메모리에 로드가 되어 있기때문에 
		실시간으로 로드하는 것이 아니기 때문에 데이터를 빠르게 읽을수 있다.
		이는 프로그램 실행속도를 향상키는데 도움이된다.


		========ROM===================

		=============메모리영역 =========================================
	
	*/


	int iNum = 0;
	
	int a = 0;

	++a;
	++a;
	
	std::cout << "a = " << a<< std::endl;

	Func();

	iNum = Add(10, 20);
	
	std::cout << "iNum = " << iNum << std::endl;


	g_StaticNum++;		//이 스태틱변수는 cal헤더에 있다 근데 main에 있는 g_StaticNum는 cal헤더에 있는 변수랑 상관이없다 이유는 서로 해당지역이 다르다 주소가 다르기 때문이다.
	g_StaticNum++;

	CalFunc();
	CalFunc2();

	std::cout << "Main 함수의 스태틱 값 :" << g_StaticNum << std::endl;

	StaticAddress();
	StaticAddress2();

	std::cout << "Main 함수의 스태틱 변수의 주소값 : " << &g_StaticNum << std::endl;

	StaticFunc();
	StaticFunc();
	StaticFunc();
	StaticFunc();
	StaticFunc();

	ExternFunc();


	std::cout << "Main함수의 g_Num 주소값 : " << &g_Num << std::endl;
	
	ExternAddress();
	

	//

	

	
	return 0;
}